/*
    too costly : float4 data = FetchClampBilinear(_Source, layerUV, _ScreenParams);

*/
#pragma kernel CSExtrudeScene

#include "UnityCG.cginc"

#include "../Includes/CamUtils.hlsl"
#include "../Includes/TransformUtils.hlsl"

#include "../Includes/SDFPrimitivesBase.hlsl"
#include "../Includes/SDFOperations.hlsl"

#include "../Includes/ColorFunctions.hlsl"
#include "../Includes/Intersectors.hlsl"
#include "../Includes/Interpolators.hlsl"

#include "../Includes/Utils.hlsl"
#include "../Includes/Noises.hlsl"
#include "../Includes/Encoding.hlsl"


// built-in global, https://docs.unity3d.com/Manual/SL-CameraDepthTexture.html
// Texture2D<float4> _LastCameraDepthTexture;

Texture2D<float4> _Source;
SamplerState sampler_Source;
RWTexture2D<float4> _Destination;


///////////////////////////////////////////////////////////////////////////
// ray container for this render, could be added distortion factor here
struct Ray {

    float3 or;
    float3 dir;

    float tmin;
    float tmax;

    float3 pos;
};

#define _L_MAXSTEP 64
#define _FAR_Z 0.5
#define _MAX_DEPTH 1.0

// static const float3 sun = float3(0.57, 0.5, -0.9);
#define _SUN normalize(float3(0.57, 0.5, -0.9))

//---------------------------------------------------------- Map
float2 MapLayer(in float3 pos){

    float2 res = float2(0.0, 1);

    // get screen coordinate at layer depth and get texture data
    float2 layerUV = WorldToScreenUv(float3(pos.xy, 0), unity_WorldToCamera, unity_CameraProjection);
    float4 data = _Source[layerUV * _ScreenParams.xy]; // MUCH CHEAPER but ugly
    // // float4 data = TextureNice(_Source, sampler_Source, layerUV, _ScreenParams); // Cost ok

    //-- start temp, fetch the data twice
    // pos.xy -= data.ba;
    // float4x4 rot = RotationAxisAngle( normalize(float3(0.,1.0,0.0)), _Time.z);
    // float4x4 txx = transpose(rot);
    // pos = mul(txx, float4(pos, 1.0)).xyz;
    // pos.xy += data.ba;

    // layerUV = WorldToScreenUv(float3(pos.xy, 0), unity_WorldToCamera, unity_CameraProjection);
    // data = _Source[layerUV * _ScreenParams.xy]; // CHEAPER but ugly
    //-- end temp

    // modulate 2d dist
    float round = 0.4;
    data.r += round;

    fixed4 gpack = FloatToRGBA(data.g);
    float ext = gpack.r;
    float txZ = gpack.g;


    float depth = _MAX_DEPTH * ext;
    txZ = _MAX_DEPTH * (1 - ext) * txZ;
    pos.z -= _FAR_Z; // add back dist and txZ

    depth *= 0.5; // extrude both side    
    pos.z += txZ + depth;

    // displace here
    float fdpth = clamp(pos.z/depth,-1,1)*0.5+0.5;
    fdpth = Parabola(fdpth, 0.25);
    
    data.r = OpExtrusion(pos, data.r, depth);
    data.r -= fdpth * round;

    // res = float2(data.r, extrude);
    res = OpUnion(res, float2(data.r, 1.5));
    return res;
}

float3 CalcNormal( in float3 pos ){

    // const float ep = 0.0001;
    const float ep = 0.05;

    float2 e = float2(1.0,-1.0)*0.5773;
    return normalize( e.xyy*MapLayer( pos + e.xyy*ep ).x + 
					  e.yyx*MapLayer( pos + e.yyx*ep ).x + 
					  e.yxy*MapLayer( pos + e.yxy*ep ).x + 
					  e.xxx*MapLayer( pos + e.xxx*ep ).x );

}

//---------------------------------------------------------- lightin func
float CalcSoftShadow( in float3 ro, in float3 rd, float tmin, float tmax, const float k ){

	float res = 1.0;
    float t = tmin;
    for( int i=0; i<32; i++ )
    {
		float h = MapLayer( ro + rd*t ).x;
        res = min( res, k*h/t );
        t += clamp( h, 0.02, 0.20 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

float CalcSoftShadow( in float3 ro, in float3 rd, float tmin, float tmax ){

    float res = 1.0;
    float t = tmin;

    for( int i=0; i<16; i++ )
    {
		float h = MapLayer( ro + rd*t ).x;

        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

//---------------------------------------------------------- render materials
float4 RenderVoxel(float4 col, Ray r, float4 nordt){
    
    float dif = clamp( dot(nordt.xyz, _SUN), 0.0, 1.0);
    float4 vcol;
    vcol.rgb = float3(0.18,0.0125,0.0125) + dif * float3(1.0,0.9,0.8) * 1.5;
    vcol.a = 0.025;

    return BlendUnder(col, vcol);
}

float4 RenderSurface(in float4 col, Ray r, float4 nordt){

    float4 scol = 0.1;
    // float4 scol = 1;
    float sha = 1;

    float dif = clamp( dot(nordt.xyz, _SUN), 0.0, 1.0);

    // sha = CalcSoftShadow( r.pos, _SUN, 0.00001, 1, 1.0 );
    // sha = CalcSoftShadow( r.pos, _SUN, 0.00001, 0.1 );

    scol.rgb = float3(0.01,0.0125,0.125) + dif * sha * float3(1.0,0.9,0.8) * 1.5;

    return BlendUnder(col, scol);
}

//---------------------------------------------------------- ray marcher
float4 MarchLayer(Ray r){

    float surfThick = 0.01;
    float t = r.tmin;

    float step = (r.tmax - r.tmin)/_L_MAXSTEP;
    float4 col = 0;

    for(int i = 0; i < _L_MAXSTEP; i++)
    {
        r.pos = r.or + r.dir * t;
        float2 d = MapLayer(r.pos);
        
        if(d.x < 0)
        {
            float4 nordt = float4(CalcNormal(r.pos), d.x);
            if(d.x > -surfThick) col = RenderSurface(col, r, nordt);
            col = RenderVoxel(col, r, nordt);
            // break;
        }
        t += step;
        if(t > r.tmax)break;
    }
    return col;
}

//
float4 ExtrudeScene(uint3 id){

    float4 col = 0;
    float2 ndc = (2.0 * id.xy -_ScreenParams.xy) / _ScreenParams.xy;

    Ray ray; CreateCameraRay(ndc, unity_CameraToWorld, unity_CameraInvProjection, ray.or, ray.dir);
    
    // far clip is at Layer's Depth
    ray.tmax = IPlane(ray.or, ray.dir, float4(0,0,-1, _FAR_Z));

    // near clip calculated from far
    float3 pfar = ray.or + ray.dir * ray.tmax;
    float dcp = length(float3(pfar.xy, ray.or.z) - pfar);

    // keep max(0) to work from within at tmin 0
    ray.tmin = (ray.tmax / dcp) * max(0, dcp - _MAX_DEPTH);

    // distort ray start point
    ray.tmin -= Blue(ndc * 0.125) * 0.05; // TMP
    
    col = MarchLayer(ray);
    return col;
}

///////////////////////////////////////////////////////////////////////////
[numthreads(8,8,1)]
void CSExtrudeScene (uint3 id : SV_DispatchThreadID)
{
    // _Destination[id.xy] = _LastCameraDepthTexture[id.xy] * 10.0;

    // _Destination[id.xy] = _Source[id.xy];
    _Destination[id.xy] = ExtrudeScene(id);
}





